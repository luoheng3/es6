/*
Created by 14486 on 2019/10/27.
*/
// es6一次声明多个变量可以使用结构赋值
let [a,b,c] = [1,2,3]; // 完全结构

// 不完全结构赋值
let [e,f] = [2,3,4]; // e=2 f=3; 右边多
// 变量左边多
let[j,k] = [1]; // k = undefined;

let [q,[w]] = [1,2]; // 当左边是一个还可以结构的模式 而右边是一个值的时候就会报错

// 解构赋值允许指定默认值。
// 默认值生效的条件是 严格等于`undefined`
let [x=3] = [];  // 3
// es5
var t = t || 3;
// 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
let [y = fn()] = [2]; // fn()并不会执行 除非 [] undefined

// ...展开运算符  会把后面的剩余全部放在一个数组里面
let [o,...p] = [1,2,3,4,5];  // p === [2,3,4,5]

let n = [1,2,3];
//console.log(...n) 1 2 3 ...t就会把t里面的内容全部拿出来 应用 类数组变数组 函数参数

// 对象的结构赋值 是通过找同名属性
let {l:e,h:r} = { //这里的Lh并不应该理解为属性 应该抽象成匹配模式
    l:1, //这里也是  其实质是l:e,h:r; 真正的变量其实是x y;
    h:2
};

let {max} = Math; // 左边 {max:max} = Math有max这个属性 所以 max就是方法
console.log(max(2,13)); // 15

// 字符串的解构赋值
const [a, b, c, d, e] = 'hello'; // h e l l o

// 函数参数的解构赋值
function add([a,b]){
    return a+b;
}
add([2,3]);  //5
// 函数参数的解构也可以使用默认值。
function move({x = 0, y = 0} = {}) {
    return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]

// 注意，下面的写法会得到不一样的结果。
function move1({x, y} = { x: 0, y: 0 }) {
    return [x, y];
}

move1({x: 3, y: 8}); // [3, 8]
move1({x: 3}); // [3, undefined]
move1({}); // [undefined, undefined]
move1(); // [0, 0]
// 上面代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，
// 所以会得到与前一种写法不同的结果。

/*
 * 结构赋值不能使用圆括号的情况
 *   1:变量声明语句let
 *   2:函数参数
 *   3: 赋值语句的模式
 */